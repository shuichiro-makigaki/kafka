import {app, BrowserWindow, dialog, ipcMain, Menu, MenuItem, shell} from 'electron';
import {execFile, spawn, ChildProcess} from 'child_process';
import Store from 'electron-store';
import fs from 'fs';
import log from 'electron-log';
import {default as axios} from 'axios';
import * as path from 'path';
import getPort from 'get-port';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const Walk = require('@root/walk');

import {MovieModel} from './models';

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

let SERVER_PROC: ChildProcess;
let MAIN_WINDOW: BrowserWindow;
const KAFKA_CLI_PATH = path.resolve(__dirname, 'kafka-server.exe');
let SERVER_PORT = 8080;
type ConfigType = {
  recentWindowPosition: number[],
  recentWindowSize: number[]
}
const CONFIG = new Store<ConfigType>();

async function createWindow() {
  createAppMenu();

  const pos = CONFIG.get('recentWindowPosition', [0, 0]);
  const size = CONFIG.get('recentWindowSize', [1600, 900]);
  // Create the browser window.
  MAIN_WINDOW = new BrowserWindow({
    width: size[0], height: size[1],
    x: pos[0], y: pos[1],
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  MAIN_WINDOW.on('close', () => {
    if (SERVER_PROC) {
      SERVER_PROC.kill();
    }
    const [x, y] = MAIN_WINDOW.getPosition();
    CONFIG.set('recentWindowPosition', [x, y]);
    const [w, h] = MAIN_WINDOW.getSize();
    CONFIG.set('recentWindowSize', [w, h]);
  });

  const databaseFile = CONFIG.get('recentDatabaseFile');
  if (fs.existsSync(`${databaseFile}`)) {
    SERVER_PORT = await getPort();
    SERVER_PROC = spawn(KAFKA_CLI_PATH, ['serve', '--database', `${databaseFile}`]);
    SERVER_PROC.stdout.on('data', chunk => {
      log.info(chunk.toString());
    });
    SERVER_PROC.stderr.on('data', chunk => {
      log.error(chunk.toString());
    })
    SERVER_PROC.on('error', err => {
      log.error(err);
    });
    SERVER_PROC.on('exit', (code, signal) => {
      log.info(`exit by signal ${signal} with code ${code}`);
    });
    SERVER_PROC.on('close', (code, signal) => {
      log.info(`close by signal ${signal} with code ${code}`);
    });
  }

  // and load the index.html of the app.
  MAIN_WINDOW.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
}

function updateDatabase(movieDir: string, thumbnailCount: number) {
  const movies: MovieModel[] = [];
  MAIN_WINDOW.webContents.send('sendMessage', `Listing files in ${movieDir} ...`);
  Walk.walk(movieDir, async (err: any, pathname: string, dirent: fs.Dirent) => {
    if (err) {
      MAIN_WINDOW.webContents.send('sendMessage', `${err}`);
      return
    }
    if (dirent.isDirectory()) {
      return
    }
    const resp = await axios.post('http://localhost:8080/movie', {path: pathname});
    const meta = await axios.get(`http://localhost:8080/movie/${resp.data.id}/thumbnail`);
    if (meta.data.count < thumbnailCount) {
      const m = new MovieModel();
      m.file = pathname;
      m.id = resp.data.id;
      m.title = path.basename(m.file);
      movies.push(m);
    }
  }).then(async () => {
    let i = 0;
    for (const m of movies) {
      MAIN_WINDOW.webContents.send('sendMessage', `(${i+1}/${movies.length}) Rendering ${m.file} ...`);
      await axios.post(`http://localhost:8080/movie/${m.id}/thumbnail`, {thumbnailCount: thumbnailCount})
          .catch(reason => {
            log.error(reason);
          });
      MAIN_WINDOW.webContents.send('sendPercent', i++/movies.length*100);
    }
    MAIN_WINDOW.webContents.send('sendPercent', 100);
    MAIN_WINDOW.webContents.send('sendMessage', '');
  });
}

function createAppMenu() {
  const templateMenu = [
    new MenuItem({
      label: 'Database',
      submenu: [
        {
          label: 'Create database',
          click(item, window, event) {
            const databaseFile = dialog.showSaveDialogSync({title: 'New database'});
            if (databaseFile) {
              MAIN_WINDOW.webContents.send('sendMessage', `New database ${databaseFile}`);
              CONFIG.set('recentDatabaseFile', databaseFile);
              if (SERVER_PROC) {
                SERVER_PROC.kill();
              }
              SERVER_PROC = spawn(KAFKA_CLI_PATH, ['serve', '--database', databaseFile]);
              SERVER_PROC.stdout.on('data', chunk => {
                log.info(chunk.toString());
              });
              SERVER_PROC.stderr.on('data', chunk => {
                log.error(chunk.toString());
              })
              SERVER_PROC.on('error', err => {
                log.error(err);
              });
              SERVER_PROC.on('exit', (code, signal) => {
                log.info(`exit by signal ${signal} with code ${code}`);
              });
              SERVER_PROC.on('close', (code, signal) => {
                log.info(`close by signal ${signal} with code ${code}`);
              });
              MAIN_WINDOW.reload();
            }
          }
        },
        {
          label: 'Open database',
          click(item, w, event) {
            const files = dialog.showOpenDialogSync({properties: ['openDirectory']});
            if (files) {
              const databaseFile = files[0];
              MAIN_WINDOW.webContents.send('sendMessage', `Open database ${databaseFile}`);
              CONFIG.set('recentDatabaseFile', databaseFile);
              if (SERVER_PROC) {
                SERVER_PROC.kill();
              }
              SERVER_PROC = spawn(KAFKA_CLI_PATH, ['serve', '--database', databaseFile]);
              SERVER_PROC.stdout.on('data', chunk => {
                log.info(chunk.toString());
              });
              SERVER_PROC.stderr.on('data', chunk => {
                log.error(chunk.toString());
              })
              SERVER_PROC.on('error', err => {
                log.error(err);
              });
              SERVER_PROC.on('exit', (code, signal) => {
                log.info(`exit by signal ${signal} with code ${code}`);
              });
              SERVER_PROC.on('close', (code, signal) => {
                log.info(`close by signal ${signal} with code ${code}`);
              });
              MAIN_WINDOW.reload();
            }
          }
        },
        {
          label: 'Add movies',
          click(item, window, event) {
            const files = dialog.showOpenDialogSync({properties: ['openDirectory']});
            if (files) {
              updateDatabase(files[0], Number(CONFIG.get('recentThumbnailCount', 3)));
            }
          }
        }
      ]
    }),
    new MenuItem({
      role: 'editMenu',
      submenu: [
        {
          label: 'Set player',
          click(item, window, event) {
            const files = dialog.showOpenDialogSync({properties: ['openFile']});
            if (files) {
              CONFIG.set('defaultPlayer', files[0]);
              MAIN_WINDOW.webContents.send('sendMessage', `Player is set to ${files[0]}`);
            }
          }
        }
      ]
    }),
    new MenuItem({
      label: 'View',
      submenu: [
        {
          label: 'Sort',
          submenu: [
            {
              label: 'Last modified time',
              type: 'radio',
              id: '.view.sort.last_modified_time',
              click(item, window, event) {
                CONFIG.set('recentSortType', 'last_modified_time');
                MAIN_WINDOW.webContents.send('sendSortType', 'last_modified_time');
              }
            },
            {
              label: 'Random',
              type: 'radio',
              id: '.view.sort.random',
              click(item, window, event) {
                CONFIG.set('recentSortType', 'random');
                MAIN_WINDOW.webContents.send('sendSortType', 'random');
              }
            },
          ]
        },
        {
          label: 'Thumbnails',
          submenu: [
            {
              label: '3',
              type: 'radio',
              id: '.view.thumbnails.3',
              click(item, window, event) {
                CONFIG.set('recentThumbnailCount', 3);
                MAIN_WINDOW.webContents.send('sendThumbnailCount', 3);
              }
            },
            {
              label: '5',
              type: 'radio',
              id: '.view.thumbnails.5',
              click(item, window, event) {
                CONFIG.set('recentThumbnailCount', 5);
                MAIN_WINDOW.webContents.send('sendThumbnailCount', 5);
              }
            }
          ]
        }
      ],
    }),
    new MenuItem({
      role: 'windowMenu',
      submenu: [
        {
          role: 'reload'
        }
      ]
    }),
    new MenuItem({
      role: 'help',
      submenu: [
        {
          role: 'toggleDevTools'
        },
        {
          label: 'Open log directory',
          click(item, window, event) {
            shell.showItemInFolder(log.transports.file.getFile().path);
          }
        }
      ]
    })
    // For MacOS
    // new MenuItem({
    //   role: 'appMenu'
    // }),
    // new MenuItem({
    //   role: 'about'
    // })
  ];
  const menu = Menu.buildFromTemplate(templateMenu);
  const sortType = CONFIG.get('recentSortType', 'last_modified_time');
  menu.getMenuItemById(`.view.sort.${sortType}`).checked = true;
  const thumbnailCount = CONFIG.get('recentThumbnailCount', 3);
  menu.getMenuItemById(`.view.thumbnails.${thumbnailCount}`).checked = true;
  Menu.setApplicationMenu(menu);
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

ipcMain.handle('openMovieContextMenu', (event, movie: MovieModel) => {
  const templateMenu = [
    new MenuItem({
      label: 'Delete',
      click(item, window, event) {
        MAIN_WINDOW.webContents.send('deleteMovie', movie.id);
      }
    }),
    new MenuItem({
      label: 'Generate thumbnails',
      click(item, window, event) {
        MAIN_WINDOW.webContents.send('generateThumbnails', movie.id);
      }
    })
  ];
  Menu.buildFromTemplate(templateMenu).popup();
});

ipcMain.handle('openMovie', (event, movie: MovieModel) => {
  const player = CONFIG.get('defaultPlayer');
  execFile(`${player}`,  [movie.file], (err, stdout, stderr) => {
    if (err !== null) {
      log.info(err.cmd);
    }
    log.info(stderr);
    log.info(stdout);
  });
});

ipcMain.handle('getRecentSortType', () => {
  return CONFIG.get('recentSortType', 'last_modified_time');
});

ipcMain.handle('getRecentThumbnailCount', () => {
  return CONFIG.get('recentThumbnailCount', 3);
});

